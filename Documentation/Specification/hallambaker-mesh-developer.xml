<?xml version='1.0'?>
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd'>
<rfc ipr="trust200902" docName="draft-hallambaker-mesh-developer-04" category="info">
<?rfc toc="yes"?>  
<?rfc symrefs="yes"?>  
<?rfc sortrefs="yes"?>  
<?rfc compact="yes"?>  
<?rfc subcompact="no"?>  
<front>
<title abbrev="Mathematical Mesh Developer">Mathematical Mesh: Reference Implementation</title>
<author fullname="Phillip Hallam-Baker" initials="P. M." surname="Hallam-Baker">
<organization>Comodo Group Inc.</organization>
<address>
<email>philliph@comodo.com</email>
</address>
</author>
<date day="21" month="August" year="2017"/>
<area/>
<workgroup/>
<abstract>
<t>
The Mathematical Mesh ?The Mesh? is an end-to-end secure infrastructure that facilitates the exchange of configuration and credential data between multiple user devices.</t>
<t>
This document describes the Mesh reference code and how to install, run and make use of it in applications. It does not form a part of the Mesh specifications and is not normative.</t>
<t>
This document is also available online at <eref target="http://prismproof.org/Documents/draft-hallambaker-mesh-developer.html">
http://prismproof.org/Documents/draft-hallambaker-mesh-developer.html</eref>
.</t>
</abstract>
</front>
<middle>
<section title="Definitions" anchor="s-1">
<t>
This section presents the related specifications and standard, the terms that are used as terms of art within the documents and the terms used as requirements language.</t>
<section title="Requirements Language" anchor="s-1_1">
<t>
This document is not normative and does not contain requirements language</t>
</section>
<section title="Defined Terms" anchor="s-1_2">
<t>
The terms of art used in this document are described in the Mesh Architecture Guide <xref target="draft-hallambaker-mesh-architecture">
[draft-hallambaker-mesh-architecture]</xref>
.</t>
</section>
<section title="Related Specifications" anchor="s-1_3">
<t>
The architecture of the Mathematical Mesh is described in the Mesh Architecture Guide <xref target="draft-hallambaker-mesh-architecture">
[draft-hallambaker-mesh-architecture]</xref>
. The Mesh documentation set and related specifications are described in this document.</t>
</section>
<section title="Implementation Status" anchor="s-1_4">
<t>
The implementation status of the reference code base is described in the companion document <xref target="draft-hallambaker-mesh-developer">
[draft-hallambaker-mesh-developer]</xref>
.</t>
</section>
</section>
<section title="Getting the Reference Code and Build Tools" anchor="s-2">
<t>
The Mesh Reference library was developed using Visual Studio 2017 Community Edition <xref target="VS2017">
[VS2017]</xref>
 using PHB?s Build Tools <xref target="PHB2017">
[PHB2017]</xref>
 extensions. The reference code itself is currently limited to C# libraries.</t>
<t>
The code should in theory run under other operating systems but this has not been tested recently. </t>
<t>
Development under different development environments is also possible but would require re-engineering to make use of the line mode versions of the build tools.</t>
<section title="Obtaining the Development Environment" anchor="s-2_1">
<t>
Visual Studio 2015 Community Edition is currently available at no cost for a wide range of non-commercial development including personal use and development of Open Source software. For full details, please consult the license published by Microsoft.</t>
<figure anchor="s-2_1-2">
<artwork>
<![CDATA[https://www.visualstudio.com/]]></artwork>
</figure>
</section>
<section title="Obtaining the Build Tools" anchor="s-2_2">
<t>
Over half the code in the reference code library is generated using code generators. These are used to ensure that the specification, examples and reference code are always kept in synchronization. </t>
<t>
The build tools are published under an MIT License and are available in two forms:</t>
<t>
As stand-alone tools to be run from the command line.</t>
<t>
As a VSIX package that integrates into the Visual Studio environment.</t>
<t>
The source distribution is configured to use the tools integrated into the Visual Studio environment. If development on other platforms is desired, the simplest approach is likely to be to write a tool that reads the Visual Studio configuration files and generates the corresponding files for use with make.</t>
<t>
The VSIX package is available from the Visual Studio extensions gallery:</t>
<figure anchor="s-2_2-7">
<artwork>
<![CDATA[PHB Code Generation Tools]]></artwork>
</figure>
<t>
The source code for the build tools is available from:</t>
<figure anchor="s-2_2-9">
<artwork>
<![CDATA[https://sourceforge.net/projects/phb-build-tools/]]></artwork>
</figure>
</section>
<section title="Obtaining the Mesh Source Libraries" anchor="s-2_3">
<t>
The Mesh reference library source code is published under an MIT license and is available from:</t>
<figure anchor="s-2_3-2">
<artwork>
<![CDATA[https://sourceforge.net/projects/mathematicalmesh/]]></artwork>
</figure>
</section>
</section>
<section title="Running the Reference Code Examples" anchor="s-3">
<t>
The reference code examples are designed to illustrate how the Mesh might be used in an application rather than be standalone tools in their own right. The Mesh is designed to make it each for developers to add security to their own applications rather than providing the applications themselves.</t>
<section title="Starting the Server" anchor="s-3_1">
<t>
On the Windows platform, the server runs in the context of the platform Web server and must be granted permission to bind to the range of server addresses used using the netsh command.</t>
<t>
From a command prompt with administrator privileges, run the following command:</t>
<figure anchor="s-3_1-3">
<artwork>
<![CDATA[netsh http add urlacl http://<domain>/.well-known/mmm/ 
    \user=<machine>\<user>]]></artwork>
</figure>
<t>
Where  is the DNS domain name under which the service is run,  is the Windows domain name of the machine and  the account name.</t>
<t>
To start the service from the command line type:</t>
<figure anchor="s-3_1-6">
<artwork>
<![CDATA[servermesh <domain>]]></artwork>
</figure>
<t>
The server does not require administration privileges.</t>
</section>
<section title="The Profile Manager Wizard" anchor="s-3_2">
<t>
The profile manager wizard demonstrates functions that are performed on an administration device. These include creating a completely new profile and initial configuration of applications, connecting a device to the profile and recovery of the profile from escrow data.</t>
<t>
To run the client from the command line, place the executable image in a location that it will be found in the PATH variable and type:</t>
<figure anchor="s-3_2-3">
<artwork>
<![CDATA[meshclient]]></artwork>
</figure>
</section>
<section title="The Profile Connection Wizard" anchor="s-3_3">
<t>
The Profile connection wizard demonstrates the much more restricted functionality that would be required in a Mesh connected application and/or a profile manager for a non-administration device.</t>
<t>
To run the client from the command line, place the executable image in a location that it will be found in the PATH variable and type:</t>
<figure anchor="s-3_3-3">
<artwork>
<![CDATA[meshconnect]]></artwork>
</figure>
</section>
</section>
<section title="Platform specific configuration data" anchor="s-4">
<section title="Windows" anchor="s-4_1">
<section title="Private Key Data" anchor="s-4_1_1">
<t>
All private key data is stored using the Windows public key store. At minimum, this ensures that private keys are obfuscated and encrypted under the account password to protect the data against casual extraction attacks. On a machine with cryptographic hardware support such as a TPM or HSM, extraction of the private key may be infeasible without physical access to the machine and possibly require sophisticated diagnostic equipment.</t>
</section>
<section title="Registry settings" anchor="s-4_1_2">
<t>
Separate settings are used for production and test code. Test Code should use the Registry Hive:</t>
<t>
HKEY_CURRENT_USER\SOFTWARE\CryptoMesh</t>
<t>
Production code should use the hive</t>
<t>
HKEY_CURRENT_USER\SOFTWARE\MathematicalMesh</t>
<t>
In either case the sub structure is:</t>
<t><list style="hanging">
<t>
Contains the set of Mesh Portal Accounts for the user. The default value is the account name of the default account. The Name of the each key is a portal account name and the value a REG_SZ entry containing the UDF of the profile master key.</t>
<t>
Contains the set of Mesh Profiles for the user. The default value is the UDF of the default profile master key. The Name of each key is the UDF of the master key and the value a REG_SZ entry containing the file location of the cached copy of the personal profile.</t>
<t>
Contains the set of Device profiles in the same format as the PersonalProfiles.</t>
</list></t>
</section>
<section title="Profile data files" anchor="s-4_1_3">
<t>
The profile data itself is stored in data files at the location specified in the registry. The files are standard XML files in UTF8 encoding.</t>
</section>
</section>
<section title="OSX and Linux" anchor="s-4_2">
<t>
[[Not yet implemented, subject to change.]</t>
<t>
All configuration information is stored in the user directory ~/.mmm</t>
<t>
Keys are stored in SSH key file format <xref target="RFC4716">
[RFC4716]</xref>
 using the customary name and extension conventions for that application. </t>
</section>
</section>
<section title="Using the Mesh C#/.Net Libraries in an Application" anchor="s-5">
<t>
The application ExampleGenerator shows the use of the Mesh in an application using the convenience API. It is the application program used to generate the examples in the reference document.</t>
<t>
ExampleGenerator implements a client that connects to a remote Web Service, creates new personal profile with an escrow entry with offline recovery codes, attaches applications and other devices, updates an application profile, deletes all the profile data from the local machine and then restores them using the recovery codes and escrow entry.</t>
<section title="Portals, Sessions and Clients" anchor="s-5_1">
<t>
The libraries are designed to support testing and development use. For this reason, the client side of the libraries is divided into the following main classes:</t>
<t><list style="hanging">
<t>
Provides a logical connection to a remote or simulated Mesh service.</t>
<t>
Provides the interface to a Mesh service which may be an actual remote service accessed via a network connection, or local code running in the same process as the client to simulate a Mesh service for testing purposes.</t>
<t>
Provides an interface to Mesh data stored on the local machine.</t>
<t>
Provides the high level application interface to the Mesh combining access through the MeshClient and MeshMachine. </t>
</list></t>
<t>
The relationship between these parts is shown in . The application programmer will typically need only the MeshSession class.</t>
<t>
The principal classes in the Mesh Client side API.</t>
<t>
This division makes it possible to test Mesh clients and server implementations in a single process with a single debugger which is usually more convenient than spinning up a separate development session for the client and service.</t>
</section>
<section title="Creating a Mesh Session" anchor="s-5_2">
<t>
The normal method of creating a Portal Client connection is?</t>
<t>
</t>
<t>
Connecting to a remote service from a Windows platform.</t>
<t>
</t>
<t>
</t>
<figure anchor="s-5_2-6">
<artwork>
<![CDATA[        static MeshSession MeshSession = null;

        static void ApplicationInit () {
            MeshWindows.Initialize(true);
            MeshSession = new MeshSession();
            }]]></artwork>
</figure>
</section>
<section title="Creating a Mesh Session for Testing" anchor="s-5_3">
<t>
</t>
<t>
Connecting to a direct service for testing.</t>
<t>
</t>
<t>
</t>
<figure anchor="s-5_3-5">
<artwork>
<![CDATA[        static void DebugApplicationInit () {

            MeshPortal.Default = new MeshPortalDirect("example.com",
                "MeshLog.jlog", "PortalLog.jlog");

            MeshWindows.Initialize(true);
            MeshSession = new MeshSession();
            MeshSession.EraseTest();
            }]]></artwork>
</figure>
<t>
Since the purpose of the ExampleGenerator is to create examples for the documentation, it is not necessary for the JSON Remote Procedure Calls to actually be ?Remote?. Instead the ?Local? Procedure Call mode is used in which the client and server both run in the same process with the client API invoking the server dispatch methods through an interface that performs JSON serialization and deserialization but does not invoke the network transport.</t>
<t>
For purposes of testing and initial development of a Web Service it is frequently desirable to further simplify the implementation by dispensing with the serialization layer and the client calling the server dispatch methods directly.</t>
</section>
<section title="Checking that a Portal Account name is acceptable" anchor="s-5_4">
<t>
</t>
<figure anchor="s-5_4-2">
<artwork>
<![CDATA[        PersonalProfile PersonalProfile;
        RegistrationPersonal RegistrationPersonal;
        OfflineEscrowEntry OfflineEscrowEntry;

        void DebugCreateProfile (string Address) {
            var Response = MeshSession.Validate(Address);
            if (!Response.Valid) {
                throw new Exception();
                }
            ...]]></artwork>
</figure>
</section>
<section title="Creating a Personal Profile" anchor="s-5_5">
<t>
</t>
<figure anchor="s-5_5-2">
<artwork>
<![CDATA[            var Device = MeshSession.CreateDevice();
            PersonalProfile = new PersonalProfile(Device.DeviceProfile);
            RegistrationPersonal = MeshSession.CreateAccount(
                "alice@example.com", PersonalProfile);]]></artwork>
</figure>
<t>
</t>
</section>
<section title="Creating an Offline Escrow Entry" anchor="s-5_6">
<figure anchor="s-5_6-1">
<artwork>
<![CDATA[
            OfflineEscrowEntry = new OfflineEscrowEntry(
                PersonalProfile, 2, 4);
            RegistrationPersonal.Escrow(OfflineEscrowEntry);]]></artwork>
</figure>
</section>
<section title="Attaching a New Device" anchor="s-5_7">
<t>
</t>
<figure anchor="s-5_7-2">
<artwork>
<![CDATA[        void RequestConnect (string Address) {
            var DeviceRegistration = MeshSession.CreateDevice();
            var Connect = MeshSession.Connect(DeviceRegistration);

            MeshSession.Await(Connect);
            }]]></artwork>
</figure>
<t>
</t>
<figure anchor="s-5_7-4">
<artwork>
<![CDATA[        void AcceptPending () {
            var Pending = MeshSession.ConnectPending();
            foreach (var Request in Pending.Pending) {
                var Result = MeshSession.ConnectClose(Request, 
                    ConnectionStatus.Accepted);
                }
            }]]></artwork>
</figure>
<t>
</t>
</section>
<section title="Attaching a New Application" anchor="s-5_8">
<figure anchor="s-5_8-1">
<artwork>
<![CDATA[            var PasswordProfile = new PasswordProfile(true);
            var RegistrationApplication =
                    RegistrationPersonal.Add(PasswordProfile, false);]]></artwork>
</figure>
</section>
<section title="Deleting Profile Data" anchor="s-5_9">
<figure anchor="s-5_9-1">
<artwork>
<![CDATA[            RegistrationPersonal.Delete();]]></artwork>
</figure>
</section>
<section title="Recovering Profile Data" anchor="s-5_10">
<figure anchor="s-5_10-1">
<artwork>
<![CDATA[            var RecoveryShares = new KeyShare[] {
                OfflineEscrowEntry.KeyShares[0],
                OfflineEscrowEntry.KeyShares[2] };
            var Secret = new Secret(RecoveryShares);
            MeshSession.Recover(Secret);
            }]]></artwork>
</figure>
</section>
</section>
<section title="Using other languages" anchor="s-6">
<t>
If you are building Mesh applications in another language, the least effort approach may be to rewrite the PROTOGEN build tool to target your language.</t>
<t>
Protogen does support generation of C header files that may be used to drive a parser. If however you are adding Mesh support for an application that already uses JSON based protocols, you might want to edit the generator scripting files to generate code for your existing libraries.</t>
<section title="Lightweight Binding" anchor="s-6_1">
<t>
</t>
<t>
Plan to create a limited binding to provide the core features used by an application, possibly running on a restricted device. This excludes most account management features:</t>
<t><list style="symbols">
<t>
Creating new Personal Profiles and portal accounts.</t>
<t>
Key escrow, recovery</t>
<t>
List, accept pending device connection requests</t>
</list></t>
<t>
This leaves the following features:</t>
<t><list style="symbols">
<t>
Create Device Profile</t>
<t>
Request device connection</t>
<t>
Get Personal Profile</t>
<t>
Get, Update, Application Profile</t>
</list></t>
<t>
In addition to providing less functionality, an implementation of the lightweight binding is likely to be written in a 'flattened' style rather than the abstracted, object oriented approach of the reference code.</t>
<t>
</t>
</section>
</section>
<section title="Implementation Status" anchor="s-7">
<t>
This section records the status of known implementations of the protocol defined by this specification at the time of posting of this Internet-Draft, and is based on a proposal described in <xref target="RFC6892">
[RFC6892]</xref>
.  The description of implementations in this section is intended to assist the IETF in its decision processes in progressing drafts to RFCs.  Please note that the listing of any individual implementation here does not imply endorsement by the IETF.  Furthermore, no effort has been spent to verify the information presented here that was supplied by IETF contributors. This is not intended as, and must not be construed to be, a catalog of available implementations or their features.  Readers are advised to note that other implementations may exist. </t>
<t>
According to <xref target="RFC6892">
[RFC6892]</xref>
, "this will allow reviewers and working groups to assign due consideration to documents that have the benefit of running code, which may serve as evidence of valuable experimentation and feedback that have made the implemented protocols more mature.  It is up to the individual working groups to use this information as they see fit". </t>
<section title="Reference Implementation" anchor="s-7_1">
<t>
Organization: Comodo Group Inc.</t>
<t>
Implementer: Phillip Hallam-Baker</t>
<t>
Maturity: Experimental Prototype</t>
<t>
This implementation was used to produce the reference section and all the examples in this document. Since the conversion of specification to code is automatic, there is a high degree of assurance that the reference implementation is consistent with this document.</t>
<section title="Coverage:" anchor="s-7_1_1">
<t>
The draft-xx branch describes the code used to create version xx of this document.</t>
<t>
The main current limitations are that the code only supports RSA key pairs and for ease of development the server does not persist keys across sessions. Nor does the implementation currently support the HTTP payload authentication and encryption layer or make use of TLS. These could be easily fixed.</t>
<t>
The client and server are implemented as libraries that may be called from a multi-protocol server. A standalone server will be provided in a future release.</t>
<t>
Only the JSON encoding is currently implemented. The JSON-B, JSON-C, ASN.1 and TLS Schema implementations are all supported by the code generation tool but not currently implemented as the build tool bindings for those encodings have not yet been finalized or documented.</t>
<t>
The key restrictions for TLS key exchange have not yet been implemented.</t>
<t>
The code has only been tested on Windows 10 but passed compatibility testing for both Mono and dotNetCore 10 run times which should in theory permit use on Linux and OSX platforms.</t>
</section>
<section title="Licensing" anchor="s-7_1_2">
<t>
The code is released under an MIT License</t>
<t>
Source code is available from GitHub at https://github.com/hallambaker/Mathematical-Mesh</t>
</section>
<section title="Implementation Experience" anchor="s-7_1_3">
<t>
The implementation and specification documentation were developed in Visual Studio using the PHB Build Tools suite.</t>
</section>
<section title="Contact Info" anchor="s-7_1_4">
<t>
Contact Phillip Hallam-Baker phill@hallambaker.com</t>
</section>
</section>
</section>
<section title="Security Considerations" anchor="s-8">
<t>
Security Considerations are addressed in the companion document <xref target="draft-hallambaker-mesh-architecture">
[draft-hallambaker-mesh-architecture]</xref>
</t>
</section>
<section title="IANA Considerations" anchor="s-9">
<t>
This document specifies no actions for IANA</t>
</section>
<section title="Acknowledgements" anchor="s-10">
<t>
Comodo Group: Egemen Tas, Melhi Abdulhayo?lu, Rob Stradling, Robin Alden.</t>
</section>
</middle>
<back>
<references title="Normative References">
<reference anchor="RFC4716">
<front>
<title>The Secure Shell (SSH) Public Key File Format</title>
<author fullname="J. Galbraith" initials="J." surname="Galbraith">
<organization/>
<address>
</address>
</author>
<author fullname="R. Thayer" initials="R." surname="Thayer">
<organization/>
<address>
</address>
</author>
<date month="November" year="2006"/>
</front>
<seriesInfo name="RFC" value="4716"/>
<seriesInfo name="DOI" value="10.17487/RFC4716"/>
</reference>
</references>
<references title="Informative References">
<reference anchor="RFC6892">
<front>
<title>The 'describes' Link Relation Type</title>
<author fullname="E. Wilde" initials="E." surname="Wilde">
<organization/>
<address>
</address>
</author>
<date month="March" year="2013"/>
</front>
<seriesInfo name="RFC" value="6892"/>
<seriesInfo name="DOI" value="10.17487/RFC6892"/>
</reference>
<reference anchor="draft-hallambaker-mesh-architecture">
<front>
<title>Mathematical Mesh: Architecture</title>
<author fullname="Phillip Hallam-Baker" initials="P" surname="Hallam-Baker">
<organization/>
<address>
</address>
</author>
<date day="9" month="May" year="2017"/>
</front>
<seriesInfo name="Internet-Draft" value="draft-hallambaker-mesh-architecture-03"/>
<format type="TXT" target="http://www.ietf.org/internet-drafts/draft-hallambaker-mesh-architecture-03.txt"/>
</reference>
<reference anchor="draft-hallambaker-mesh-developer">
<front>
<title>Mathematical Mesh: Reference Implementation</title>
<author fullname="Phillip Hallam-Baker" initials="P" surname="Hallam-Baker">
<organization/>
<address>
</address>
</author>
<date day="18" month="August" year="2017"/>
</front>
<seriesInfo name="Internet-Draft" value="draft-hallambaker-mesh-developer-03"/>
<format type="TXT" target="http://www.ietf.org/internet-drafts/draft-hallambaker-mesh-developer-03.txt"/>
</reference>
<reference anchor="VS2017">
<front>
<title>[Reference Not Found!]</title>
<author initials="" surname="">
<organization/>
<address>
</address>
</author>
<date/>
</front>
</reference>
<reference anchor="PHB2017">
<front>
<title>[Reference Not Found!]</title>
<author initials="" surname="">
<organization/>
<address>
</address>
</author>
<date/>
</front>
</reference>
</references>
</back>
</rfc>
