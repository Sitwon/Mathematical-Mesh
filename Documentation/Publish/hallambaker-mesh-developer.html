<?xml version='1.0'?>
<html>
<head>
<title>Mathematical Mesh Developer</title>
</head>
<body>
<h1>Mathematical Mesh: Developer's Guide</h1>
<h1 class="abstract" id="Abstract">Abstract</h1>
<P class="abstract">The Mathematical Mesh 'The Mesh' is an end-to-end secure infrastructure that facilitates the exchange of configuration and credential data between multiple user devices.</P>
<P class="abstract">This document describes how to install and run the Mesh reference code and make use of the reference code in applications. It does not form a part of the Mesh specifications and is not normative.</P>
<h1 id="Section_1">Getting the Reference Code and Build Tools</h1>
<p id="">The Mesh Reference library was developed using Visual Studio 2015 Community Edition using PHB's Build Tools extensions. The reference code itself is currently limited to C# libraries.</p>
<p id="">The code should in theory run under other operating systems but this is not currently tested. </p>
<p id="">Development under different development environments is also possible but would require re-engineering to make use of the line mode versions of the build tools.</p>
<h2 id="Section_1_1">Obtaining the Development Environment</h2>
<p id="">Visual Studio 2015 Community Edition is currently available at no cost for a wide range of non-commercial development including personal use and development of Open Source software. For full details, please consult the license published by Microsoft.</p>
<pre id="">
<![CDATA[https://www.visualstudio.com/]]></pre>
<h2 id="Section_1_2">Obtaining the Build Tools</h2>
<p id="">Over half the code in the reference code library is generated using code generators. These are used to ensure that the specification, examples and reference code are always kept in synchronization. </p>
<p id="">The build tools are published under an MIT License and are available in two forms:</p>
<p id="">As stand-alone tools to be run from the command line.</p>
<p id="">As a VSIX package that integrates into the Visual Studio environment.</p>
<p id="">The source distribution is configured to use the tools integrated into the Visual Studio environment. If development on other platforms is desired, the simplest approach is likely to be to write a tool that reads the Visual Studio configuration files and generates the corresponding files for use with make.</p>
<p id="">The VSIX package is available from the Visual Studio extensions gallery:</p>
<pre id="">
<![CDATA[PHB Code Generation Tools]]></pre>
<p id="">The source code for the build tools is available from:</p>
<pre id="">
<![CDATA[https://sourceforge.net/projects/phb-build-tools/]]></pre>
<h2 id="Section_1_3">Obtaining the Mesh Source Libraries</h2>
<p id="">The Mesh reference library source code is published under an MIT license and is available from:</p>
<pre id="">
<![CDATA[https://sourceforge.net/projects/mathematicalmesh/]]></pre>
<h1 id="Section_2">Running the Reference Code Examples</h1>
<p id="">The reference code examples are designed to illustrate how the Mesh might be used in an application rather than be standalone tools in their own right. The Mesh is designed to make it each for developers to add security to their own applications rather than providing the applications themselves.</p>
<h2 id="Section_2_1">Starting the Server</h2>
<p id="">On the Windows platform, the server runs in the context of the platform Web server and must be granted permission to bind to the range of server addresses used using the netsh command.</p>
<p id="">From a command prompt with administrator privileges, run the following command:</p>
<pre id="">
<![CDATA[netsh http add urlacl http://<domain>/.well-known/mmm/ 
    \user=<machine>\<user>]]></pre>
<p id="">Where  is the DNS domain name under which the service is run,  is the Windows domain name of the machine and  the account name.</p>
<p id="">To start the service from the command line type:</p>
<pre id="">
<![CDATA[servermesh <domain>]]></pre>
<p id="">The server does not require administration privileges.</p>
<h2 id="Section_2_2">The Profile Manager Wizard</h2>
<p id="">The profile manager wizard demonstrates functions that are performed on an administration device. These include creating a completely new profile and initial configuration of applications, connecting a device to the profile and recovery of the profile from escrow data.</p>
<p id="">To run the client from the command line, place the executable image in a location that it will be found in the PATH variable and type:</p>
<pre id="">
<![CDATA[meshclient]]></pre>
<h2 id="Section_2_3">The Profile Connection Wizard</h2>
<p id="">The Profile connection wizard demonstrates the much more restricted functionality that would be required in a Mesh connected application and/or a profile manager for a non-administration device.</p>
<p id="">To run the client from the command line, place the executable image in a location that it will be found in the PATH variable and type:</p>
<pre id="">
<![CDATA[meshconnect]]></pre>
<h1 id="Section_3">Platform specific configuration data</h1>
<h2 id="Section_3_1">Windows</h2>
<h3 id="Section_3_1_1">Private Key Data</h3>
<p id="">All private key data is stored using the Windows public key store. At minimum, this ensures that private keys are obfuscated and encrypted under the account password to protect the data against casual extraction attacks. On a machine with cryptographic hardware support such as a TPM or HSM, extraction of the private key may be infeasible without physical access to the machine and possibly require sophisticated diagnostic equipment.</p>
<h3 id="Section_3_1_2">Registry settings</h3>
<p id="">Separate settings are used for production and test code. Test Code should use the Registry Hive:</p>
<p id="">HKEY_CURRENT_USER\SOFTWARE\CryptoMesh</p>
<p id="">Production code should use the hive</p>
<p id="">HKEY_CURRENT_USER\SOFTWARE\MathematicalMesh</p>
<p id="">In either case the sub structure is:</p>
<dl>
<dl>
<dt>Accounts</dt>
<dd>Contains the set of Mesh Portal Accounts for the user. The default value is the account name of the default account. The Name of the each key is a portal account name and the value a REG_SZ entry containing the UDF of the profile master key.</dd>
<dt>PersonalProfiles</dt>
<dd>Contains the set of Mesh Profiles for the user. The default value is the UDF of the default profile master key. The Name of each key is the UDF of the master key and the value a REG_SZ entry containing the file location of the cached copy of the personal profile.</dd>
<dt>ThisDevice</dt>
<dd>Contains the set of Device profiles in the same format as the PersonalProfiles.</dd>
</dl>
</dl>
<h3 id="Section_3_1_3">Profile data files</h3>
<p id="">The profile data itself is stored in data files at the location specified in the registry. The files are standard XML files in UTF8 encoding.</p>
<h2 id="Section_3_2">OSX and Linux</h2>
<p id="">[[Not yet implemented, subject to change.]</p>
<p id="">All configuration information is stored in the user directory ~/.mmm</p>
<p id="">Keys are stored in SSH key file format [RFC4716] using the customary name and extension conventions for that application. </p>
<h1 id="Section_4">Using the Mesh C#/.Net Libraries in an Application</h1>
<p id="">The application ExampleGenerator shows the use of the Mesh in an application using the convenience API. It is the application program used to generate the examples in the reference document.</p>
<p id="">ExampleGenerator implements a client that connects to a remote WebService, creates new personal profile with an escrow entry with offline recovery codes, attaches applications and other devices, updates an application profile, deletes all the profile data from the local machine and then restores them using the recovery codes and escrow entry.</p>
<h2 id="Section_4_1">Creating a Portal Client Connection</h2>
<p id="">The normal method of creating a Portal Client connection is?</p>
<p id="">Since the purpose of the ExampleGenerator is to create examples for the documentation, it is not necessary for the JSON Remote Procedure Calls to actually be 'Remote'. Instead the 'Local' Procedure Call mode is used in which the client and server both run in the same process with the client API invoking the server dispatch methods through an interface that performs JSON serialization and deserialization but does not invoke the network transport.</p>
<p id="">?.</p>
<p id="">For purposes of testing and initial development of a Web Service it is frequently desirable to further simplify the implementation by dispensing with the serialization layer and the client calling the server dispatch methods directly.</p>
<p id="">?.</p>
<h2 id="Section_4_2">Checking that a Portal Account name is acceptable</h2>
<h2 id="Section_4_3">Creating a Personal Profile</h2>
<h2 id="Section_4_4">Creating an Offline Escrow Entry</h2>
<h2 id="Section_4_5">Publishing the Profile and Escrow Entries</h2>
<h2 id="Section_4_6">Attaching a New Device</h2>
<h2 id="Section_4_7">Attaching a new Application</h2>
<h2 id="Section_4_8">Deleting Profile Data</h2>
<h2 id="Section_4_9">Recovering Profile Data</h2>
<h1 id="Section_5">Using other languages</h1>
<p id="">If you are building Mesh applications in another language, the least effort approach may be to rewrite the PROTOGEN build tool to target your language.</p>
<p id="">Protogen does support generation of C header files that may be used to drive a parser. If however you are adding Mesh support for an application that already uses JSON based protocols, you might want to edit the generator scripting files to generate code for your existing libraries.</p>
<h2 id="Section_5_1">Using the C Binding</h2>
<h1 id="Section_6">Reference Code Architecture</h1>
<h2 id="Section_6_1">Protocol Definition</h2>
<h3 id="Section_6_1_1">Serialization</h3>
<h3 id="Section_6_1_2">Deserialization</h3>
<h3 id="Section_6_1_3">Class library</h3>
<h2 id="Section_6_2">Profile</h2>
<h3 id="Section_6_2_1">Generation</h3>
<h3 id="Section_6_2_2">Validation</h3>
<h3 id="Section_6_2_3">Operations</h3>
<h2 id="Section_6_3">Server </h2>
<h3 id="Section_6_3_1">Management Class</h3>
<h3 id="Section_6_3_2">Dispatch Class</h3>
<h3 id="Section_6_3_3">Connection Modes</h3>
<h4 id="Section_6_3_3_1">Direct</h4>
<h4 id="Section_6_3_3_2">Local</h4>
<h4 id="Section_6_3_3_3">Remote</h4>
<h2 id="Section_6_4">Client</h2>
<h3 id="Section_6_4_1">Stub Library</h3>
<h3 id="Section_6_4_2">Convenience API</h3>
<h1 id="Section_7">Security Considerations</h1>
<p id="">Security Considerations are addressed in the companion document [draft-hallambaker-mesh-architecture-01]</p>
<h1 id="Section_8">IANA Considerations</h1>
<p id="">IANA Considerations are addressed in the companion document [draft-hallambaker-mesh-architecture-01]</p>
<h1 id="Section_9"> Acknowledgements</h1>
<p id="">Comodo Group: Egemen Tas, Melhi Abdulhayo?lu, Rob Stradling, Robin Alden.</p>
<h1>References</h1>
<h2 class="references" id="NormativeReferences">Normative References</h2>
</body>
</html>
