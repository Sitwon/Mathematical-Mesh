
//  Test
//  
//  This file was automatically generated at 11/3/2015 5:22:53 PM
//   
//  Changes to this file may be overwritten without warning
//  
//  Generator:  GoedelShell version 1.0.0.0
//      Goedel Script Version : 0.1   Generated 
//      Goedel Schema Version : 0.1   Generated
//  
//      Copyright : Copyright ©  2012
//  
//  Build Platform: Win32NT 6.2.9200.0
//  
//  
// This file is automatically generated from the following source files:
// Command line options: 
//     /dlexer=False
//     /dparser=False
//     /dstack=False

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Goedel.Registry;


//
// Namespace Goedel.Protocol
// Class Configure
//


// Types
//   TopTypeType
//       Cluster
//       Interface
//       Service
//   TypeType
//       HTTP
//       HTTPS
//       UDP
//       Member
//       Seed
//       On
//   IdType
//       ClusterHandle
//       InterfaceHandle
//       ServiceHandle
//   NamespaceType
//       Goedel.Protocol
//   ClassType
//       Configure
//   NameType
//       Id
//       Is
//       Options
//       ClusterID
//       Address
//       Domain
//       Port
//       IP
//       Server
//       Secrets
//       Interfaces
//       Log
//       Store
//       Configuration
//       Publish
//       Priority
//       Weight
//       File
//       Data
//       Policy
//   TokenType

namespace Goedel.Protocol {


    public enum ConfigureType {
        _Top,

        Cluster,
        Interface,
        UDP,
        HTTP,
        HTTPS,
        Address,
        Service,
        Publish,
        On,
        Member,
        Configuration,
        Log,
        Store,
        Seed,

        _Label,
        _Bottom
        }    
    

    public abstract partial class _Choice {
        abstract public ConfigureType _Tag ();

		public abstract void Serialize (StructureWriter Output, bool tag);
        }



    public partial class Cluster : _Choice {
        public ID<_Choice>				Id; 

        public override ConfigureType _Tag () {
            return ConfigureType.Cluster;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Cluster");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			if (tag) {
				Output.EndElement ("Cluster");
				}			
			}
		}

    public partial class Interface : _Choice {
        public ID<_Choice>				Id; 
        public _Choice					Is;
		public Member  ClusterID = new  Member();
		public List<Address>  Address = new  List <Address> ();

        public override ConfigureType _Tag () {
            return ConfigureType.Interface;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Interface");
				}

	        Output.WriteId ("Id", Id.ToString()); 
	        Is.Serialize (Output, true);
			Output.StartList ("");
		// public Member  ClusterID = new  Member();
			ClusterID.Serialize (Output, true);
			foreach (Address _e in Address) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Interface");
				}			
			}
		}

    public partial class UDP : _Choice {
		public string					Domain;
		public int						Port;

        public override ConfigureType _Tag () {
            return ConfigureType.UDP;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("UDP");
				}

			Output.WriteAttribute ("Domain", Domain);
			Output.WriteAttribute ("Port", Port);
			if (tag) {
				Output.EndElement ("UDP");
				}			
			}
		}

    public partial class HTTP : _Choice {
		public string					Domain;
		public int						Port;

        public override ConfigureType _Tag () {
            return ConfigureType.HTTP;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("HTTP");
				}

			Output.WriteAttribute ("Domain", Domain);
			Output.WriteAttribute ("Port", Port);
			if (tag) {
				Output.EndElement ("HTTP");
				}			
			}
		}

    public partial class HTTPS : _Choice {
		public string					Domain;
		public int						Port;

        public override ConfigureType _Tag () {
            return ConfigureType.HTTPS;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("HTTPS");
				}

			Output.WriteAttribute ("Domain", Domain);
			Output.WriteAttribute ("Port", Port);
			if (tag) {
				Output.EndElement ("HTTPS");
				}			
			}
		}

    public partial class Address : _Choice {
		public string					IP;

        public override ConfigureType _Tag () {
            return ConfigureType.Address;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Address");
				}

			Output.WriteAttribute ("IP", IP);
			if (tag) {
				Output.EndElement ("Address");
				}			
			}
		}

    public partial class Service : _Choice {
        public ID<_Choice>				Id; 
		public string					Server;
		public Member  ClusterID = new  Member();
		public List<Seed>  Secrets = new  List <Seed> ();
		public List<On>  Interfaces = new  List <On> ();
		public Log  Log = new  Log();
		public Store  Store = new  Store();
		public Configuration  Configuration = new  Configuration();
		public List<Publish>  Publish = new  List <Publish> ();

        public override ConfigureType _Tag () {
            return ConfigureType.Service;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Service");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.WriteAttribute ("Server", Server);
			Output.StartList ("");
		// public Member  ClusterID = new  Member();
			ClusterID.Serialize (Output, true);
			foreach (Seed _e in Secrets) {
				_e.Serialize (Output, true);
				}
			foreach (On _e in Interfaces) {
				_e.Serialize (Output, true);
				}
		// public Log  Log = new  Log();
			Log.Serialize (Output, true);
		// public Store  Store = new  Store();
			Store.Serialize (Output, true);
		// public Configuration  Configuration = new  Configuration();
			Configuration.Serialize (Output, true);
			foreach (Publish _e in Publish) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Service");
				}			
			}
		}

    public partial class Publish : _Choice {
        public REF<_Choice>				Id;
		public int						Priority;
		public int						Weight;

        public override ConfigureType _Tag () {
            return ConfigureType.Publish;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Publish");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Priority", Priority);
			Output.WriteAttribute ("Weight", Weight);
			if (tag) {
				Output.EndElement ("Publish");
				}			
			}
		}

    public partial class On : _Choice {
        public REF<_Choice>				Id;

        public override ConfigureType _Tag () {
            return ConfigureType.On;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("On");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("On");
				}			
			}
		}

    public partial class Member : _Choice {
        public REF<_Choice>				Id;

        public override ConfigureType _Tag () {
            return ConfigureType.Member;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Member");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Member");
				}			
			}
		}

    public partial class Configuration : _Choice {
		public string					File;

        public override ConfigureType _Tag () {
            return ConfigureType.Configuration;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Configuration");
				}

			Output.WriteAttribute ("File", File);
			if (tag) {
				Output.EndElement ("Configuration");
				}			
			}
		}

    public partial class Log : _Choice {
		public string					File;

        public override ConfigureType _Tag () {
            return ConfigureType.Log;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Log");
				}

			Output.WriteAttribute ("File", File);
			if (tag) {
				Output.EndElement ("Log");
				}			
			}
		}

    public partial class Store : _Choice {
		public string					File;

        public override ConfigureType _Tag () {
            return ConfigureType.Store;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Store");
				}

			Output.WriteAttribute ("File", File);
			if (tag) {
				Output.EndElement ("Store");
				}			
			}
		}

    public partial class Seed : _Choice {
		public string					Data;
		public string					Policy;

        public override ConfigureType _Tag () {
            return ConfigureType.Seed;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Seed");
				}

			Output.WriteAttribute ("Data", Data);
			Output.WriteAttribute ("Policy", Policy);
			if (tag) {
				Output.EndElement ("Seed");
				}			
			}
		}

    class _Label : _Choice {
        public REF<_Choice>            Label;

		// This method is never called. It exists only to prevent a warning when a
		// Schema does not contain a ChoiceREF element.
        public void Reach() {
            Label = null;
            }

        public override ConfigureType _Tag () {
            return ConfigureType._Label;
            }

		public override void Serialize (StructureWriter Output, bool tag) {
			Output.WriteId ("ID", Label.ToString());
			}
        }
//	}

//namespace Goedel.Registry {

    public enum StateCode {  
        _Start,
        _Choice,
        _End,

		Cluster_Start,
		Cluster__Id,				
		Interface_Start,
		Interface__Id,				
		Interface__Is,				
		Interface__Options,				
		UDP_Start,
		UDP__Domain,				
		UDP__Port,				
		HTTP_Start,
		HTTP__Domain,				
		HTTP__Port,				
		HTTPS_Start,
		HTTPS__Domain,				
		HTTPS__Port,				
		Address_Start,
		Address__IP,				
		Service_Start,
		Service__Id,				
		Service__Server,				
		Service__Options,				
		Publish_Start,
		Publish__Id,				
		Publish__Priority,				
		Publish__Weight,				
		On_Start,
		On__Id,				
		Member_Start,
		Member__Id,				
		Configuration_Start,
		Configuration__File,				
		Log_Start,
		Log__File,				
		Store_Start,
		Store__File,				
		Seed_Start,
		Seed__Data,				
		Seed__Policy,				
        }


    struct _StackItem {
        public StateCode   State;
        public Goedel.Protocol._Choice     Token;
        }

    public partial class Configure : Goedel.Registry.Parser{
        public List <Goedel.Protocol._Choice>        Top;
        public Registry	<Goedel.Protocol._Choice>	Registry;



        bool _StartOfEntry;
        public bool StartOfEntry {
            get {return _StartOfEntry;}
            private set { _StartOfEntry = value; }
            }

        StateCode								State;
        Goedel.Protocol._Choice				Current;
        List <_StackItem>						Stack;
        TokenType								CurrentToken;
        Position								CurrentPosition;
        string									CurrentText;


        public static Configure Parse(string File, Goedel.Registry.Dispatch Options) {
            var Result = new Configure();
            Result.Options = Options;

            using (Stream infile =
                        new FileStream(File, FileMode.Open, FileAccess.Read)) {
                Lexer Schema = new Lexer(File);
                Schema.Process(infile, Result);
                }

            return Result;
            }


        public Configure() {
            Top = new List<Goedel.Protocol._Choice> () ;
            Registry = new Registry <Goedel.Protocol._Choice> ();
            State = StateCode._Start;
            Stack = new List <_StackItem> ();
            _StartOfEntry = true;

			TYPE__ClusterHandle = Registry.TYPE ("ClusterHandle"); 
			TYPE__InterfaceHandle = Registry.TYPE ("InterfaceHandle"); 
			TYPE__ServiceHandle = Registry.TYPE ("ServiceHandle"); 



            }



        public TYPE<Goedel.Protocol._Choice> TYPE__ClusterHandle ;
        public TYPE<Goedel.Protocol._Choice> TYPE__InterfaceHandle ;
        public TYPE<Goedel.Protocol._Choice> TYPE__ServiceHandle ;

        private Goedel.Protocol._Choice New_Choice(string Label) {
            switch (Label) {

                case "Cluster": return NewCluster();
                case "Interface": return NewInterface();
                case "UDP": return NewUDP();
                case "HTTP": return NewHTTP();
                case "HTTPS": return NewHTTPS();
                case "Address": return NewAddress();
                case "Service": return NewService();
                case "Publish": return NewPublish();
                case "On": return NewOn();
                case "Member": return NewMember();
                case "Configuration": return NewConfiguration();
                case "Log": return NewLog();
                case "Store": return NewStore();
                case "Seed": return NewSeed();

				}
            throw new System.Exception ("Reserved word not recognized \"" + Label + "\"");
            }



        private Goedel.Protocol.Cluster NewCluster() {
            Goedel.Protocol.Cluster result = new Goedel.Protocol.Cluster();
            Push (result);
            State = StateCode.Cluster_Start;
            return result;
            }


        private Goedel.Protocol.Interface NewInterface() {
            Goedel.Protocol.Interface result = new Goedel.Protocol.Interface();
            Push (result);
            State = StateCode.Interface_Start;
            return result;
            }


        private Goedel.Protocol.UDP NewUDP() {
            Goedel.Protocol.UDP result = new Goedel.Protocol.UDP();
            Push (result);
            State = StateCode.UDP_Start;
            return result;
            }


        private Goedel.Protocol.HTTP NewHTTP() {
            Goedel.Protocol.HTTP result = new Goedel.Protocol.HTTP();
            Push (result);
            State = StateCode.HTTP_Start;
            return result;
            }


        private Goedel.Protocol.HTTPS NewHTTPS() {
            Goedel.Protocol.HTTPS result = new Goedel.Protocol.HTTPS();
            Push (result);
            State = StateCode.HTTPS_Start;
            return result;
            }


        private Goedel.Protocol.Address NewAddress() {
            Goedel.Protocol.Address result = new Goedel.Protocol.Address();
            Push (result);
            State = StateCode.Address_Start;
            return result;
            }


        private Goedel.Protocol.Service NewService() {
            Goedel.Protocol.Service result = new Goedel.Protocol.Service();
            Push (result);
            State = StateCode.Service_Start;
            return result;
            }


        private Goedel.Protocol.Publish NewPublish() {
            Goedel.Protocol.Publish result = new Goedel.Protocol.Publish();
            Push (result);
            State = StateCode.Publish_Start;
            return result;
            }


        private Goedel.Protocol.On NewOn() {
            Goedel.Protocol.On result = new Goedel.Protocol.On();
            Push (result);
            State = StateCode.On_Start;
            return result;
            }


        private Goedel.Protocol.Member NewMember() {
            Goedel.Protocol.Member result = new Goedel.Protocol.Member();
            Push (result);
            State = StateCode.Member_Start;
            return result;
            }


        private Goedel.Protocol.Configuration NewConfiguration() {
            Goedel.Protocol.Configuration result = new Goedel.Protocol.Configuration();
            Push (result);
            State = StateCode.Configuration_Start;
            return result;
            }


        private Goedel.Protocol.Log NewLog() {
            Goedel.Protocol.Log result = new Goedel.Protocol.Log();
            Push (result);
            State = StateCode.Log_Start;
            return result;
            }


        private Goedel.Protocol.Store NewStore() {
            Goedel.Protocol.Store result = new Goedel.Protocol.Store();
            Push (result);
            State = StateCode.Store_Start;
            return result;
            }


        private Goedel.Protocol.Seed NewSeed() {
            Goedel.Protocol.Seed result = new Goedel.Protocol.Seed();
            Push (result);
            State = StateCode.Seed_Start;
            return result;
            }


        static Goedel.Protocol.ConfigureType _Reserved(string Label) {
            switch (Label) {

                case "Cluster": return Goedel.Protocol.ConfigureType.Cluster;
                case "Interface": return Goedel.Protocol.ConfigureType.Interface;
                case "UDP": return Goedel.Protocol.ConfigureType.UDP;
                case "HTTP": return Goedel.Protocol.ConfigureType.HTTP;
                case "HTTPS": return Goedel.Protocol.ConfigureType.HTTPS;
                case "Address": return Goedel.Protocol.ConfigureType.Address;
                case "Service": return Goedel.Protocol.ConfigureType.Service;
                case "Publish": return Goedel.Protocol.ConfigureType.Publish;
                case "On": return Goedel.Protocol.ConfigureType.On;
                case "Member": return Goedel.Protocol.ConfigureType.Member;
                case "Configuration": return Goedel.Protocol.ConfigureType.Configuration;
                case "Log": return Goedel.Protocol.ConfigureType.Log;
                case "Store": return Goedel.Protocol.ConfigureType.Store;
                case "Seed": return Goedel.Protocol.ConfigureType.Seed;

                }
            return Goedel.Protocol.ConfigureType._Bottom;
            }


		public void Serialize (TextWriter Output) {
			Serialize (Output, OutputFormat.Goedel);
			}

		public void Serialize (TextWriter Output, OutputFormat OutputFormat) {

			StructureWriter StructureWriter = StructureWriter.GetStructureWriter (Output, OutputFormat);
			StructureWriter.StartDocument ();
			foreach (Goedel.Protocol._Choice Entry in Top) {
				Entry.Serialize (StructureWriter, true);
				}
			StructureWriter.EndDocument ();
			}


        void Push (Goedel.Protocol._Choice Token) {
            _StackItem Item = new _StackItem ();
            Item.State = State;
            Item.Token = Current;

            Stack.Add (Item);

            //Console.WriteLine ("$$$$PUSH {0}", Current);

            Current = Token;
            }

        void Pop () {
            if (Stack.Count == 0) throw new System.Exception ("Internal Parser Error");

            _StackItem Item = Stack[Stack.Count -1];
            State = Item.State;
            Current = Item.Token;

            Stack.RemoveAt (Stack.Count -1 ) ;

            //Console.WriteLine ("$$$$POP {0}", Current);
            }



        public override void Process(TokenType Token, Position Position, string Text) {
            CurrentToken = Token;
            CurrentPosition = Position;
            CurrentText = Text;

            if ((Token == TokenType.SEPARATOR) |
                (Token == TokenType.NULL) |
                (Token == TokenType.COMMENT)) return;
            if (Token == TokenType.INVALID)
                throw new System.Exception("Invalid Token");

            bool Represent = true;

            while (Represent) {
                //Console.WriteLine ("    {3}: {0} {1} '{2}'", Token, Position, Text, State);


                Represent = false;
                switch (State) {
                    case StateCode._Start:                 //      BEGIN
                        if (Token == TokenType.BEGIN) {
                            State = StateCode._Choice;
                            break;
                            }
                        else throw new System.Exception("Parser Error Expected START");

                    case StateCode._Choice:                //      LABEL Class | END
                        if (Token == TokenType.LABEL) {
                            Goedel.Protocol.ConfigureType LabelType = _Reserved (Text);
                            if (false |
									(LabelType == Goedel.Protocol.ConfigureType.Cluster) |
									(LabelType == Goedel.Protocol.ConfigureType.Interface) |
									(LabelType == Goedel.Protocol.ConfigureType.Service)) {
                                Top.Add(New_Choice(Text));
                                }
                            else {
                                throw new System.Exception("Parser Error Expected [Class]");
                                }
                            break;
                            }
                        if (Token == TokenType.END) {
                            State = StateCode._End;
                            break;
                            }
                        else throw new System.Exception("Parser Error Expected [Class]");

                    case StateCode._End:                   //      -
                        throw new System.Exception("Too Many Closing Braces");

                    case StateCode.Cluster_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Protocol.Cluster Current_Cast = (Goedel.Protocol.Cluster)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__ClusterHandle, Current_Cast);
                            State = StateCode.Cluster__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Cluster__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Interface_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Protocol.Interface Current_Cast = (Goedel.Protocol.Interface)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__InterfaceHandle, Current_Cast);
                            State = StateCode.Interface__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Interface__Id:
                        if (Token == TokenType.LABEL) {
							Goedel.Protocol.Interface Current_Cast = (Goedel.Protocol.Interface)Current;
                            Goedel.Protocol.ConfigureType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Protocol.ConfigureType.HTTP) |
									(LabelType == Goedel.Protocol.ConfigureType.HTTPS) |
									(LabelType == Goedel.Protocol.ConfigureType.UDP) ) {
                                State = StateCode.Interface__Is;
                                Current_Cast.Is = New_Choice(Text);
                                }
                            else {
                               throw new System.Exception("Parser Error Expected [HTTP HTTPS UDP ]");
                                }
                            break;
                            }
                        else throw new System.Exception("Parser Error Expected [HTTP HTTPS UDP ]");

                    case StateCode.Interface__Is:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Interface__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Interface__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for OPTIONS $$$$$
                        else if (Token == TokenType.LABEL) {
							Goedel.Protocol.Interface Current_Cast = (Goedel.Protocol.Interface)Current;
                            Goedel.Protocol.ConfigureType LabelType = _Reserved (Text);
							switch (LabelType) {
								case Goedel.Protocol.ConfigureType.Member : {

									// ClusterID  Member
									Current_Cast.ClusterID = NewMember ();
									break;
									}
								case Goedel.Protocol.ConfigureType.Address : {

									// Address  Address
									Current_Cast.Address.Add (NewAddress ());
									break;
									}
								default : {
									throw new System.Exception("Parser Error Expected [Member Address ]");
									}
								}
							}
                        break;

                    case StateCode.UDP_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Protocol.UDP Current_Cast = (Goedel.Protocol.UDP)Current;
                            Current_Cast.Domain = Text;
                            State = StateCode.UDP__Domain;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.UDP__Domain:
                        if (Token == TokenType.INTEGER) {
                            Goedel.Protocol.UDP Current_Cast = (Goedel.Protocol.UDP)Current;
                            Current_Cast.Port = Convert.ToInt32(Text);
                            State = StateCode.UDP__Port;
                            break;
                            }
                        throw new System.Exception("Expected Integer");

                    case StateCode.UDP__Port:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.HTTP_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Protocol.HTTP Current_Cast = (Goedel.Protocol.HTTP)Current;
                            Current_Cast.Domain = Text;
                            State = StateCode.HTTP__Domain;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.HTTP__Domain:
                        if (Token == TokenType.INTEGER) {
                            Goedel.Protocol.HTTP Current_Cast = (Goedel.Protocol.HTTP)Current;
                            Current_Cast.Port = Convert.ToInt32(Text);
                            State = StateCode.HTTP__Port;
                            break;
                            }
                        throw new System.Exception("Expected Integer");

                    case StateCode.HTTP__Port:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.HTTPS_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Protocol.HTTPS Current_Cast = (Goedel.Protocol.HTTPS)Current;
                            Current_Cast.Domain = Text;
                            State = StateCode.HTTPS__Domain;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.HTTPS__Domain:
                        if (Token == TokenType.INTEGER) {
                            Goedel.Protocol.HTTPS Current_Cast = (Goedel.Protocol.HTTPS)Current;
                            Current_Cast.Port = Convert.ToInt32(Text);
                            State = StateCode.HTTPS__Port;
                            break;
                            }
                        throw new System.Exception("Expected Integer");

                    case StateCode.HTTPS__Port:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Address_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Protocol.Address Current_Cast = (Goedel.Protocol.Address)Current;
                            Current_Cast.IP = Text;
                            State = StateCode.Address__IP;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Address__IP:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Service_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Protocol.Service Current_Cast = (Goedel.Protocol.Service)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__ServiceHandle, Current_Cast);
                            State = StateCode.Service__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Service__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Protocol.Service Current_Cast = (Goedel.Protocol.Service)Current;
                            Current_Cast.Server = Text;
                            State = StateCode.Service__Server;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Service__Server:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Service__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Service__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for OPTIONS $$$$$
                        else if (Token == TokenType.LABEL) {
							Goedel.Protocol.Service Current_Cast = (Goedel.Protocol.Service)Current;
                            Goedel.Protocol.ConfigureType LabelType = _Reserved (Text);
							switch (LabelType) {
								case Goedel.Protocol.ConfigureType.Member : {

									// ClusterID  Member
									Current_Cast.ClusterID = NewMember ();
									break;
									}
								case Goedel.Protocol.ConfigureType.Seed : {

									// Secrets  Seed
									Current_Cast.Secrets.Add (NewSeed ());
									break;
									}
								case Goedel.Protocol.ConfigureType.On : {

									// Interfaces  On
									Current_Cast.Interfaces.Add (NewOn ());
									break;
									}
								case Goedel.Protocol.ConfigureType.Log : {

									// Log  Log
									Current_Cast.Log = NewLog ();
									break;
									}
								case Goedel.Protocol.ConfigureType.Store : {

									// Store  Store
									Current_Cast.Store = NewStore ();
									break;
									}
								case Goedel.Protocol.ConfigureType.Configuration : {

									// Configuration  Configuration
									Current_Cast.Configuration = NewConfiguration ();
									break;
									}
								case Goedel.Protocol.ConfigureType.Publish : {

									// Publish  Publish
									Current_Cast.Publish.Add (NewPublish ());
									break;
									}
								default : {
									throw new System.Exception("Parser Error Expected [Member Seed On Log Store Configuration Publish ]");
									}
								}
							}
                        break;

                    case StateCode.Publish_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Protocol.Publish Current_Cast = (Goedel.Protocol.Publish)Current;
                            Current_Cast.Id = Registry.REF(Position, Text, TYPE__ServiceHandle, Current_Cast);
                            State = StateCode.Publish__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Publish__Id:
                        if (Token == TokenType.INTEGER) {
                            Goedel.Protocol.Publish Current_Cast = (Goedel.Protocol.Publish)Current;
                            Current_Cast.Priority = Convert.ToInt32(Text);
                            State = StateCode.Publish__Priority;
                            break;
                            }
                        throw new System.Exception("Expected Integer");

                    case StateCode.Publish__Priority:
                        if (Token == TokenType.INTEGER) {
                            Goedel.Protocol.Publish Current_Cast = (Goedel.Protocol.Publish)Current;
                            Current_Cast.Weight = Convert.ToInt32(Text);
                            State = StateCode.Publish__Weight;
                            break;
                            }
                        throw new System.Exception("Expected Integer");

                    case StateCode.Publish__Weight:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.On_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Protocol.On Current_Cast = (Goedel.Protocol.On)Current;
                            Current_Cast.Id = Registry.REF(Position, Text, TYPE__InterfaceHandle, Current_Cast);
                            State = StateCode.On__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.On__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Member_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Protocol.Member Current_Cast = (Goedel.Protocol.Member)Current;
                            Current_Cast.Id = Registry.REF(Position, Text, TYPE__ClusterHandle, Current_Cast);
                            State = StateCode.Member__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Member__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Configuration_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Protocol.Configuration Current_Cast = (Goedel.Protocol.Configuration)Current;
                            Current_Cast.File = Text;
                            State = StateCode.Configuration__File;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Configuration__File:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Log_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Protocol.Log Current_Cast = (Goedel.Protocol.Log)Current;
                            Current_Cast.File = Text;
                            State = StateCode.Log__File;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Log__File:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Store_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Protocol.Store Current_Cast = (Goedel.Protocol.Store)Current;
                            Current_Cast.File = Text;
                            State = StateCode.Store__File;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Store__File:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Seed_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Protocol.Seed Current_Cast = (Goedel.Protocol.Seed)Current;
                            Current_Cast.Data = Text;
                            State = StateCode.Seed__Data;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Seed__Data:
                        if (Token == TokenType.STRING) {
                            Goedel.Protocol.Seed Current_Cast = (Goedel.Protocol.Seed)Current;
                            Current_Cast.Policy = Text;
                            State = StateCode.Seed__Policy;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Seed__Policy:
                        Pop ();
                        Represent = true; 
                        break;

                    default:
                        throw new System.Exception("Unreachable code reached");
                    }
                }
            }
        }
	}


